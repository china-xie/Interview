### JVM 篇
1. 什么情况下会发生栈内存溢出。什么时候发生堆溢出？你是怎么排错的？
2. JVM怎么判断对象是可回收对象？有哪些方法。
3. JVM的内存结构，新生代与老年代的比例，Eden和Survivor比例。
4. 你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。
5. 简单说说你了解的类加载器，可以打破双亲委派么，怎么打破。
6. JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor。
7. JVM 出现 fullGC 很频繁，怎么去线上排查问题？
8. JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代，说说你知道的几种主要的JVM参数。
9. 垃圾回收算法的实现原理。
10. JVM内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存等。
11. 说一下Java对象的创建过程
12. 你们线上应用的JVM参数配置了哪些。
13. G1和cms区别。
14. 怎么打出线程栈信息。
15. 说一下类加载的执行过程
16. JVM垃圾回收机制，何时触发MinorGC等操作呢？
17. ZGC 垃圾收集器，了解过吗
18. 对象的访问定位有哪两种方式?
19. 说一下 jvm 调优的工具？
20. 对象什么时候会进入老年代？
21. 内存泄漏和内存溢出区别？
22. 什么是tomcat类加载机制？
23. 了解逃逸分析技术吗
24. 调用System.gc()会发生什么?
25. 谈谈Minor GC条件，full GC条件
26. Stop The World 了解过吗？
27. 谈谈你认识多少种OOM？如何避免OOM?
28. 了解过JVM调优没，基本思路是什么?如何确定它们的大小呢？
29. 淘宝热门商品信息在JVM哪个内存区域
30. 字节码的编译过程
31. Java需要开发人员回收内存垃圾吗？
32. Java中垃圾回收有什么目的？什么时候进行垃圾回收？
33. System.gc()和Runtime.gc()会做什么事情？
34. 主内存与工作内存
35. 内存间交互操作
36. volatile 禁止内存重排序
37. 内存模型三大特性
38. 谈谈先行发生原则
39.  JVM 堆内存溢出后，其他线程是否可继续工作？
40.  说一下JVM 常用参数有哪些？
41.  VM 为什么使用元空间替换了永久代？
42.  Java堆的结构是什么样子的？什么是堆中的永久代(Perm Gen space)?
43.  JVM的永久代中会发生垃圾回收么？
44.  什么是字节码？采用字节码的最大好处是什么？什么Java是虚拟机？
45.  MinorGC 的过程
46.  CPU 占用过高如何分析
47.  Serial与Parallel GC之间的不同之处？
48.  WeakHashMap 是怎么工作的？
49.  解释 Java 堆空间及 GC？
50.  你能保证 GC 执行吗？
51.  JVM中哪个参数是用来控制线程的栈堆栈小的?

52. 了解过JVM调优没，基本思路是什么，如何确定它们的大小？

如果CPU使用率较高，GC频繁且GC时间长，可能就需要JVM调优了。
    基本思路就是让每一次GC都回收尽可能多的对象，对于CMS来说，要合理设置年轻代和年老代的大小。

 这是一个迭代的过程，可以先采用JVM的默认值，然后通过压测分析GC日志。    
    如果看年轻代的内存使用率处在高位，导致频繁的Minor GC，而频繁GC的效率又不高，说明对象没那么快能被回收，这时年轻代可以适当调大一点。
    如果看年老代的内存使用率处在高位，导致频繁的Full GC，这样分两种情况：如果每次Full GC后年老代的内存占用率没有下来，可以怀疑是内存泄漏；如果Full GC后年老代的内存占用率下来了，说明不是内存泄漏，要考虑调大年老代。
    对于G1收集器来说，可以适当调大Java堆，因为G1收集器采用了局部区域收集策略，单次垃圾收集的时间可控，可以管理较大的Java堆。

53. System.gc()和Runtime.gc()会做什么事情？

这两个方法用来提示JVM要进行垃圾回收。但是，立即开始还是延迟进行垃圾回收是取决于JVM的。

54. Java中垃圾回收有什么目的？什么时候进行垃圾回收？

55. 垃圾回收的目的是识别并且丢弃应用不再使用的对象来释放和重用资源。

    触发主GC（Garbage Collector，垃圾回收）的条件：
    （1）当应用程序空闲时，即没有应用线程在运行时，GC会被调用。
    （2）Java堆内存不足时，GC会被调用。

